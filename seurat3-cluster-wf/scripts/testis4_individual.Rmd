---
title: Seurat3 Testis 4 Clustering
author: Justin Fear
date: 'Compiled: `r format(Sys.Date(), "%B %d, %Y")`'
output: 
    html_document:
        self_contained: TRUE
        keep_md: TRUE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
    collapse = TRUE,
    warning = FALSE,
    message = FALSE,
    include = FALSE,
    cache.lazy = FALSE,
    fig.path = 'testis4_figures/',
    fig.ext = c('png', 'svg'),
    fig.width = 8
)
```

```{r load_libraries}
library(Seurat)
library(dplyr)
library(ggplot2)
set.seed(42)
```

```{r globals}
SAMPLE <- 'testis4'
PROJ_DIR <- '/home/fearjm/Projects/larval_gonad'
DATA_DIR <- file.path(PROJ_DIR, 'output/cellselection-wf/testis4')
OUTDIR <- file.path(PROJ_DIR, 'output/seurat3-cluster-wf')

GENE_ANNOTATION <- file.path(PROJ_DIR, 'references/gene_annotation_dmel_r6-24.feather')
LITERATURE_GENES <- file.path(PROJ_DIR, 'config/literature_genes.yaml')
```

```{r load_gene_annotations}
fbgn2symbol <- feather::read_feather(
    GENE_ANNOTATION,
    columns = c("FBgn", "gene_symbol")
)
```

Here I explore clustering `r SAMPLE` using Seurat v3. This document will walk through the clustering process and highlights different decision points.

```{r load_10x_data}
tenX.data <- Read10X(data.dir = DATA_DIR, gene.column = 2)
sobj <- CreateSeuratObject(
    counts = tenX.data,
    min.cells = 3,
    min.features = 200,
    project = SAMPLE
)
```

## Quality Control and Filtering

First I identify additional cells to remove prior to analysis.
In particular, I want to remove GEMs that are possibly homotypic doublets as well as dead or dying cells.
Homotypic doublets will have abnormally high gene/UMI content.
Apoptotic cells will likely have high mitochondrial gene expression.
I also look for cells with high rRNA expression which may have had bad poly(A) selection.
However, both high RNA content and mitochondrial expression could be functionally important in germline development.
I would like to remove problematic cells, but not be too stringent to remove real signal.

```{r estimate_mito_content}
sobj[["percent.mt"]] <- PercentageFeatureSet(sobj, pattern = "^mt:")
```

```{r estimate_ribo_content}
sobj[["percent.ribo"]] <- PercentageFeatureSet(sobj, pattern = ".*rRNA")
```

```{r dist_basic_cnts, include=TRUE}
VlnPlot(sobj, features = c("nFeature_RNA", "nCount_RNA", "percent.mt", "percent.ribo"), pt.size = .1, ncol = 4)
```

```{r scatter_basic_cnts, fig.width=12, include=TRUE}
p1 <- FeatureScatter(sobj, feature1 = "nCount_RNA", feature2 = "percent.mt") + scale_x_log10() + xlab("UMI")
p2 <- FeatureScatter(sobj, feature1 = "nCount_RNA", feature2 = "percent.ribo") + scale_x_log10() + xlab("UMI")
p3 <- FeatureScatter(sobj, feature1 = "nCount_RNA", feature2 = "nFeature_RNA") + scale_x_log10() + xlab("UMI") + ylab("Number Genes")
CombinePlots(plots = list(p1, p2, p3), ncol = 3)
```

To identify problematic cells I plot several key features.

* `nFeature_RNA` is the number of expressed genes per cell
* `nCount_RNA` is the total UMI per cell
* `percent.mt` is the proportion of expressed genes that are mitochondrial. 
* `percent.ribo` is the proportion of expressed genes that are rRNA.

I see a break in the distribution of expressed genes around 6,000 genes (`nFeature_RNA` distribution panel) . 
Gene content is correlated (0.84) with total UMI (last scatter plot), so removing these cells would result in removal of cells above 50,000 UMI. 
There are also a number of lower expressing cells that have a high percent (>20%) of mitochondrial reads.
rRNA content is low for most cells (<1%) suggesting overall good poly(A) selection.

**Filtering criteria**

* 200 < Number of Genes <= 6,000
* percent.mt <= 20
* percent.mt <= 2

```{r filter_cells, include=TRUE}
num_cells <- dim(sobj)[2]
sobj <- subset(sobj, subset = nFeature_RNA > 200 & nFeature_RNA <= 6000 & percent.mt <= 20 & percent.ribo <= 2)
num_cells_kept <- dim(sobj)[2]
num_cells_removed <- num_cells - num_cells_kept
num_genes <- dim(sobj)[1]
```

* Starting with `r num_cells` cells.
* Removing `r num_cells_removed` cells.
* Keeping `r num_cells_kept` cells.
* Using `r num_genes` genes.

## Normalization and Scaling

I am using Seurat's default LogNormalization followed by a variance stabelizing transformation and selection of highly variable genes. 
Unlike previous v2, Seurat3 is using more variable genes (n = 2,000).
Variable genes are in red, with the top 20 variable genes annotated.
I will use these genes 2,000 genes as features during dimensionality reduction.

```{r normalize}
sobj <- NormalizeData(
    sobj,
    normalization.method = "LogNormalize",
    scale.factor = 1e4,
    verbose = FALSE
)
```

```{r find_variable_genes}
sobj <- FindVariableFeatures(sobj, selection.method = "vst", nfeatures = 2000, verbose = FALSE)
top20 <- head(VariableFeatures(sobj), 20)
```

```{r scatter_variable_genes, fig.width=10, include=TRUE}
p1 <- VariableFeaturePlot(sobj)
p2 <- LabelPoints(plot = p1, points = top20, repel = TRUE)
print(p2)
```
Similar to Seurat v2, I decided to regress out mitochondrial batch effects during scaling.

```{r scale_data, include=TRUE}
all_genes <- rownames(sobj)
sobj <- ScaleData(sobj, features = all_genes, vars.to.regress = "percent.mt", verbose = FALSE)
```

## Dimensionality Reduction

I used PCA to reduce dimensionality using the 2,000 variable genes. 
To decide how many PCs to use I look at a number of diagnostic plots.

```{r dim_reduction}
sobj <- RunPCA(sobj, features = VariableFeatures(sobj), verbose = FALSE)
```

### Dimensional Gene Loadings

```{r dotplot_pcs, fig.wdith=12, fig.height=12, include=TRUE}
VizDimLoadings(sobj, dims = 1:4, reduction = "pca", ncol = 2)
```
There are some interesting genes poping out in the first 4 PCs.

* PC1
    * *dj*
    * *ocn*
* PC2
    * *aub*
* PC3
    * *br*
    * *abd-A*
* PC4
    * *stl*
    * *Abd-B*
    * *nord*

### Top Genes Heatmap

The first metric plotting each PC with the top genes.
On the X-axis are all of the cells and on the Y-axis are the top genes driving that variation in that PC. 
I am looking through each PC and seeing if there are genes that I recognize. 
The idea being that I don't want to remove a PC that has interesting genes driving variation.
I start at the last PC and working my way up. 
PC 18 is the first to have a gene that I recognize (*w-cup*). 
However, there is not much visible structure until PC 11.

```{r heatmap_pca, fig.height=20, include=TRUE}
DimHeatmap(sobj, dims = 1:21, balanced = TRUE)
```

### JackStraw

The next method is an actual metric called JackStraw analsyis. 
In this plot we look for a large drop in the theortical vs empirical distribution. 
For sure we don't want to include any PCs that fall below the dashed line.
However, it is suggested to remove PCs after the first major drop which puts us around PC9 or PC10.

```{r run_jackstraw}
sobj <- JackStraw(sobj, num.replicate = 100, dims = 30, verbose = FALSE)
sobj <- ScoreJackStraw(sobj, dims = 1:30)
```

```{r jackstraw_pca, fig.width=12, include=TRUE}
p1 <- JackStrawPlot(sobj, dims=1:30)
p2 <- JackStrawPlot(sobj, dims=1:10)
CombinePlots(plots = list(p1, p2), ncol = 1)
```

### Elbow Plot

The elbow plot is a classic metric, plotted on the Y-axis is the variability measured by standard deviation.
On the X axis is the first 20 PCs. 
Simialar to the Jackstraw plot we want to look for a large space between points and a flattening out of the captured variation. 
This metric would suggest somewhere between PCs 5-10

```{r elbow_pca, include=TRUE}
ElbowPlot(sobj)
```

### Dimension Selection 

After looking at all of the metrics I think 10 is a good point to cut this sample off.

## Clustering 

Next I perform clustering. 
Since I am wanting to compare methods, and parameters can be adjusted to get any number of clusters, I have decided to shoot for 12-13 clusters.
From perliminary analysis we think that we capture roughly this many cell types.
I ran a range of resolutions and found for this sample around `0.6` give me 13 clusters.

```{r run_clustering}
sobj <- FindNeighbors(sobj, dims = 1:10)
sobj <- FindClusters(sobj, resolution = c(.4, .5, .6, .7, .8, .9, 1, 1.1, 1.2), verbose = FALSE)

diff_res <- sobj@meta.data %>% select(contains("res"))
for (i in 1:dim(diff_res)[[2]]){
    res <- diff_res[, i]
    name <- colnames(diff_res)[[i]]
    lvls <- levels(res)
    print(paste0(name, ':  ', length(lvls)))
}

sobj <- SetIdent(sobj, value = "RNA_snn_res.0.6")
```

```{r umap, fig.asp=1, include=TRUE}
sobj <- RunUMAP(sobj, dims = 1:10)
DimPlot(sobj, reduction = "umap") + ggtitle(paste0(SAMPLE, ': res.0.6'))
```

```{r tsne, fig.asp=1, include=TRUE}
sobj <- RunTSNE(sobj, dims = 1:10)
DimPlot(sobj, reduction = "tsne") + ggtitle(paste0(SAMPLE, ': res.0.6'))
```

```{r save_robj}
save(sobj, file = paste0(SAMPLE, '.Robj'))
```

## Look at marker genes

To get a better sense of these clusters I am plotting various known marker genes from the literature.

```{r load_lit_genes}
lit_genes <- yaml::yaml.load_file(LITERATURE_GENES)
```

### Spermatogonia

*bam* looks to be expressed in cluster 6 and 11 along with *Rbp4*, *Phf7*, *vas*, and *p53*.

```{r heatmap_gonia, fig.width=20, fig.height=20, include=TRUE}
lg <- fbgn2symbol %>% filter(FBgn %in% lit_genes[['gonia']]) %>% pull("gene_symbol")
VlnPlot(sobj, features = lg)
FeaturePlot(sobj, features = lg)
```

### Spermatocytes

The left set of clusters appear to be spermatocytes, with good expression of *aub*, *sa*, *aly*, *bol*, *fzo*, *tomb*, *kmg*, *topi*, and *nht*.
Surprisingly, *dj* and *ocn* are expressed all over.

```{r heatmap_spermatocytes, fig.width=20, fig.height=20, include=TRUE}
lg <- fbgn2symbol %>% filter(FBgn %in% lit_genes[['spermatocytes']]) %>% pull("gene_symbol")
VlnPlot(sobj, features = lg)
FeaturePlot(sobj, features = lg)
```

### CySC
*tj* shows clear expression in the right group of cells. 

```{r heatmap_cysc, fig.width=20, fig.height=20, include=TRUE}
lg <- fbgn2symbol %>% filter(FBgn %in% lit_genes[['cysc']]) %>% pull("gene_symbol")
VlnPlot(sobj, features = lg)
FeaturePlot(sobj, features = lg)
```

### TE

The TE appears to be the large island.

```{r heatmap_te, fig.width=20, fig.height=20, include=TRUE}
lg <- fbgn2symbol %>% filter(FBgn %in% lit_genes[['te']]) %>% pull("gene_symbol")
VlnPlot(sobj, features = lg)
FeaturePlot(sobj, features = lg)
```

### PC

PC appears to be the smaller island.

```{r heatmap_pc, fig.width=8, include=TRUE}
lg <- fbgn2symbol %>% filter(FBgn %in% lit_genes[['pigment']]) %>% pull("gene_symbol")
VlnPlot(sobj, features = lg)
FeaturePlot(sobj, features = lg)
```

### hub

The hub genes overlap the TE island and some of the cells in the tail.

```{r heatmap_hub, fig.width=20, fig.height=20, include=TRUE}
lg <- fbgn2symbol %>% filter(FBgn %in% lit_genes[['hub']]) %>% pull("gene_symbol")
VlnPlot(sobj, features = lg)
FeaturePlot(sobj, features = lg)
```

## Cluster Markers

Next I identified a number of genes that are differentially upregulated in each cluster. 
These genes can be used as markers that that cluster.
Cluster 5 only had 20 genes, while the other clusters had `>=100`

```{r find_markers}
biomarkers <- FindAllMarkers(sobj, only.pos = TRUE, verbose = FALSE)
```

```{r num_markers_per_cluster, include=TRUE}
biomarkers %>% filter(p_val_adj <= 0.001) %>% group_by(cluster) %>% summarise(num_markers_per_cluster = n()) %>% print(n=nrow(.))
```

```{r top_markers}
top_markers <- biomarkers %>% filter(p_val_adj <= 0.001) %>% group_by(cluster) %>% top_n(n = 12, wt= avg_logFC)
```

Here I plot the top 12 genes for each cluster.

```{r plot_top_markers, fig.width=20, fig.height=20, include=TRUE}
for (i in 0:12){
    features <- top_markers %>% filter(cluster == i) %>% pull(gene)
    p1 <- FeaturePlot(sobj, features = features)
    t1 <- grid::textGrob(paste0('Cluster: ', i), gp=grid::gpar(cex=3))
    gridExtra::grid.arrange(p1, top=t1)
}
```

```{r save_biomarkers}
write.table(biomarkers, file = file.path(OUTDIR, paste(SAMPLE, "biomarkers.tsv", sep='_')), sep = "\t", quote = FALSE, row.names = FALSE, col.names = TRUE)
```

---
title: Ovary vs Testis DSX+ Cells
author: Justin M Fear
email: justin.m.fear@gmail.com
---

```{r, include=FALSE}
knitr::opts_chunk$set(collapse=TRUE, warning=FALSE, message=FALSE,
                      bootstrap.show.code=FALSE, bootstrap.show.output=FALSE,

                      # try disabling this when running locally for nicer figures
                      #dev='bitmap',

                      fig.ext='png')
```

```{r setup}
library(tibble)
library(DESeq2)
library(pheatmap)
library(RColorBrewer)
library(ggplot2)

# Assumption: path name to sampletable
sample.table.filename = '../config/sampletable.tsv'

colData <- read.table(sample.table.filename, sep='\t', header=TRUE, stringsAsFactors=FALSE)
# Assumption: which columns in sampletable, and that "group" should be factor
colData$tissue <- factor(colData$tissue)
```

```{r}
countData = read.table('../data/raw.tsv', sep='\t', stringsAsFactors=FALSE, header=TRUE, row.names=1)
dds <- DESeqDataSetFromMatrix(countData, colData, ~tissue)

# Calculate rlog norm
rld <- rlog(dds, blind=FALSE)

# Run DESeq
dds <- DESeq(dds)
res = results(dds, contrast=c('tissue', 'ovary', 'testis'), alpha=.05)
```

```{r}
# export
df <- as.data.frame(res[!is.na(res$padj) & res$padj <= 0.05, ])
df <- rownames_to_column(df, 'FBgn')
write.table(df, file='../output/ovary_vs_tesits_padj05.tsv', sep='\t', quote=FALSE, row.names=FALSE)

bg = row.names(res[!is.na(res$baseMean) & res$baseMean > 0, ])
fh <- file('../output/background.txt')
writeLines(bg, fh)
close(fh)
```


```{r}
#' Re-order results by log2FoldChange
#'
#' @param res DESeq2 results object
#' @param reverse If TRUE then sort high-to-low
lfc.order <- function(res, reverse=FALSE){
    res.na <- res[!is.na(res$log2FoldChange),]
    if (!reverse){
        return(res.na[order(res.na$log2FoldChange),])
    }
    if (reverse){
        return(res.na[rev(order(res.na$log2FoldChange)),])
    }
}

#' Re-order results by adjusted pval
#'
#' @param res DESeq2 results object
#' @param reverse If TRUE then sort high-to-low
padj.order <- function(res, reverse=FALSE){
    res.na <- res[!is.na(res$log2FoldChange) & !is.na(res$log2FoldChange),]
    if (!reverse){
        res.na <- res.na[res.na$log2FoldChange > 0,]
    } else {
        res.na <- res.na[res.na$log2FoldChange < 0,]
    }
    return(res.na[order(res.na$padj),])
}

```

# Gene ontology and KEGG pathway enrichment

Here we perform gene ontology enrichment and KEGG pathway enrichment using the
[clusterProfiler](https://bioconductor.org/packages/release/bioc/vignettes/clusterProfiler/inst/doc/clusterProfiler.html)
package with some custom plotting functions.

```{r}
# These are some helper functions for working with clusterProfiler results.
# While clusterProfiler does a great job of unifying the output of different
# enrichment metrics into a single data structure, we need a couple more things
# for very flexibly plotting with ggplot2. These functions handle the enrichment
# and summary of results.

#' Run enrichGO on each of the three top-level ontologies
#'
#' @param genes Gene IDs with format matching `keytype`
#' @param univers Universe of genes assayed
#' @param orgdb String or OrgDb object
#' @param keytype ID type of genes
#"
#' @return  List of clusterProfiler output objects, length 3 where names are
#' ontologies (BP, MF, CC)
clusterprofiler.enrichgo <- function(genes, universe, orgdb, keytype='ENSEMBL'){
    lst <- list()
    if (length(genes) > 0 ){
        for (ont in c('BP', 'MF', 'CC')){
            ggo <- enrichGO(gene=genes, ont=ont, universe=universe,
                            OrgDb=orgdb, keyType=keytype, pAdjustMethod='BH',
                            pvalueCutoff=0.01, qvalueCutoff=0.05,
                            readable=TRUE)
            lst[[ont]] <- ggo
        }
    }
    return(lst)
}

#' Run KEGG enrichment
#'
#' @param genes Gene IDs typically in UniProt format
#' @param org 3-character KEGG species ID (dme, hsa, mmu)
#' @param keytype ID type of genes
#'
#' @return clusterProfiler output object
clusterprofiler.enrichkegg <- function(genes, org, keyType='uniprot'){
    x <- enrichKEGG(gene=genes, organism=org, keyType='uniprot',
                    pvalueCutoff=0.05)
    return(x)
}

#' Convert "1/100" to 0.01.
#'
#' clusterProfiler report columns that are strings of numbers; this converts to
#' a fraction
#'
#' @param x Character vector to convert
get.frac <- function(x){
    y <- as.numeric(strsplit(x, '/')[[1]])
    return(y[[1]] / y[[2]])
}

#' Summarize and aggregate multiple GO results
#'
#' Convert a list of GO analysis results (one per ontology) to a single
#' dataframe, with additional label column filled in with `label` and with
#' a fraction column.
#'
#' @param ego List of clusterProfiler results objects
#' @param labels List of labels. For each name, a new column will be added and
#"        its contents will be the value
#'
#' @return dataframe
summarize.go <- function(ego, labels){
  lst <- list()
  for (name in names(ego)){
    d <- as.data.frame(ego[[name]])
    if (nrow(d) > 0){
      d$ontology <- name
      for (label in names(labels)){
        d[label] <- labels[[label]]
      }
      d$frac <- sapply(d$GeneRatio, get.frac)
    }
    lst[[name]] <- d
  }
  df <- do.call(rbind, lst)
  return(df)
}


#' Summarize KEGG results
#'
#' Summarize KEGG results and add `frac` and `label` columns
#'
#' @param ekg Results from clusterProfiler KEGG enrichment
#' @param label Attach this label to the "label" column
#'
#' @return Dataframe
summarize.kegg <- function(ekg, labels){
  d <- as.data.frame(ekg)
  if (nrow(d) > 0){
    d$ontology <- 'kegg'
    for (label in names(labels)){
      d[label] <- labels[[label]]
    }
    d$frac <- sapply(d$GeneRatio, get.frac)
  }
  return(d)
}
```

```{r, cache=TRUE}
# Here we summarize the results into dataframes and attach additional
# information to them such that they can be concatenated together into a large
# tidy dataframe.
universe <- names(dds)
enrich.list <- list()
for (name in names(sel.list)){
  for (sel in names(sel.list[[name]])){
    sel.res <- sel.list[[name]][[sel]]

    # GO enrichment
    go.label <- paste(name, sel, 'go', sep='.')
    message(paste(go.label, '...'))
    sg <- summarize.go(
      clusterprofiler.enrichgo(sel.res$gene, universe, orgdb),
      list(label=go.label, sel=sel, experiment=name))
    if (!is.null(sg)){
      enrich.list[[go.label]] <- sg
    }

    # KEGG enrichment
    kegg.label <- paste(name, sel, 'kegg', sep='.')
    message(paste(kegg.label, '...'))
    sk <- summarize.kegg(
      clusterprofiler.enrichkegg(sel.res$uniprot, kegg.org),
      list(label=kegg.label, sel=sel, experiment=name))
    if (!is.null(sk)){
      enrich.list[[kegg.label]] <- sk
    }
  }
}
```

These plots show:

- enriched category (y-axis)
- magnitude of enrichment (x-axis; plotted as -10 log10 (FDR) or "phred" scale)
- fraction of regulated genes falling within a particular category (size)
- experiment (color)
- ontology (sub-panels; BP=biological process, MF=molecular function,
  CC=cellular component, kegg=KEGG pathway)
- direction of regulation (up- or downregulated; separate figures; labeled at the top)

The plots show the top 50 terms, and are sorted by the max enrichment across
experiments.

```{r}
full.enrich.table <- do.call(rbind, enrich.list)
write.table(full.enrich.table, file='functional_enrichment.tsv', row.names=FALSE, sep='\t')
```

The full analysis table can be viewed here:

- [functional_enrichment.tsv](functional_enrichment.tsv)

```{r, go, fig.height=15, dev=c('pdf', 'png')}
# While clusterProfiler has canned figures, it's difficult to customize them.
# Instead, here we create a tidy dataframe of all experiments, directions, and
# enrichment analyses so that we can plot them with ggplot2 however the
# experiment dictates


lim <- 50
nchunks <- 1

# Assumption: all experiments have the same selections
for (sel in names(sel.list[[1]])){
  mdcat('## ', sel)
  m <- do.call(rbind, enrich.list)

  ###compute description length distribution for entire ontology
  length.quantile <- quantile(nchar(as.vector(m$Description, mode="character")), 0.75)


  # convert to phred score, and flip the "downregulated"
  m$phred <- -10 * log10(m$p.adjust)
  idx <- m$sel == sel

  m <- m[idx,]

  if (nrow(m) == 0){next}

  # Grab the top (ordered by phred)
  m$Description <- factor(m$Description)
  max.per.term <- aggregate(phred~Description, m, FUN=max)
  o <- rev(order(max.per.term$phred))
  m$Description <- factor(m$Description, levels=rev(max.per.term$Description[o]))
  top.terms <- (max.per.term$Description[o][seq(lim)])
  m.sub <- m[m$Description %in% top.terms,]
  m.sub$Description <- droplevels(m.sub$Description)
  m.sub <- m.sub[order(m.sub$Description),]

  chunksize <- ceiling(lim / nchunks)
  lookup <- rep(1:nchunks, each=chunksize)
  m.sub$chunk <- 0
  for (i in seq(length(lookup))){
    term <- as.character(top.terms[i])
    lab <- lookup[i]
    m.sub$chunk[m.sub$Description == term] = lab
  }

  #replace ontology descriptions with truncations to make plot prettier
  temp.desc <- as.vector(m.sub$Description, mode="character")
  needs.replacement <- which(nchar(temp.desc) > length.quantile)
  temp.desc <- strtrim(temp.desc, length.quantile)
  temp.desc[needs.replacement] <- paste(temp.desc[needs.replacement], "...", sep="")
  m.sub$Description <- factor(temp.desc)

print(ggplot(m.sub) +
    geom_point(alpha=0.6) +
    aes(y=Description, x=phred, size=frac, color=experiment) +
    theme(text=element_text(size=12)) +
    facet_grid(ontology~sel, scales='free_y', space='free_y')
  )
}
```

